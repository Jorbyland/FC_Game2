// Assets/Shaders/EnemyComputeShader.compute
#pragma kernel ClearCells
#pragma kernel BuildGrid
#pragma kernel MoveEnemies

// --- Structures ---
struct EnemyData {
    float3 position;
    float3 velocity;
    float health;
    float padding; // aligment 16bytes
};

RWStructuredBuffer<EnemyData> enemies;

// Grid
RWStructuredBuffer<int> cellCounts;         // length = numCells
RWStructuredBuffer<int> cellIndices;        // length = numCells * maxPerCell

int gridOriginX;
int gridOriginZ;
int gridWidth;
int gridHeight;
float cellSize;
int maxPerCell;

// Player + params
float3 playerPos;
float deltaTime;
float speed;
float repulsionRadius;
float repulsionStrength;
float minDistanceForNormalize; // e.g. 0.001

// --------------------
// Kernel: clear counts
[numthreads(256,1,1)]
void ClearCells (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= gridWidth * gridHeight) return;
    cellCounts[idx] = 0;
}

// --------------------
// Kernel: build grid lists
[numthreads(256,1,1)]
void BuildGrid (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= enemies.Length) return;

    EnemyData e = enemies[i];
    int gx = (int)floor((e.position.x - (float)gridOriginX) / cellSize);
    int gz = (int)floor((e.position.z - (float)gridOriginZ) / cellSize);

    // clamp inside grid
    gx = clamp(gx, 0, gridWidth - 1);
    gz = clamp(gz, 0, gridHeight - 1);
    int cellId = gz * gridWidth + gx;

    int old;
    // InterlockedAdd increments atomically and returns old value in 'old'
    InterlockedAdd(cellCounts[cellId], 1, old);

    // if there's still space, write index into cellIndices
    if (old < maxPerCell)
    {
        int baseIndex = cellId * maxPerCell;
        cellIndices[baseIndex + old] = (int)i;
    }
    // else overflow: ignore extra neighbors in this cell (tunable)
}

// --------------------
// Kernel: move enemies using neighbor list (repulsion from nearby enemies)
[numthreads(256,1,1)]
void MoveEnemies (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= enemies.Length) return;

    EnemyData e = enemies[i];

    // --- move toward player (basic) ---
    float3 toPlayer = playerPos - e.position;
    float distToPlayer = length(toPlayer);
    float3 dirToPlayer = float3(0,0,0);
    if (distToPlayer > minDistanceForNormalize)
        dirToPlayer = toPlayer / distToPlayer;

    float3 desiredVel = dirToPlayer * speed;

    // --- neighbor search via grid (3x3 cells) ---
    int gx = (int)floor((e.position.x - (float)gridOriginX) / cellSize);
    int gz = (int)floor((e.position.z - (float)gridOriginZ) / cellSize);
    gx = clamp(gx, 0, gridWidth - 1);
    gz = clamp(gz, 0, gridHeight - 1);

    float3 avoidance = float3(0,0,0);
    int neighborCount = 0;
    float rr2 = repulsionRadius * repulsionRadius;

    // iterate neighbor cells -1..1 in x and z
    for (int dz = -1; dz <= 1; dz++)
    {
        int nz = gz + dz;
        if (nz < 0 || nz >= gridHeight) continue;
        for (int dx = -1; dx <= 1; dx++)
        {
            int nx = gx + dx;
            if (nx < 0 || nx >= gridWidth) continue;

            int nCellId = nz * gridWidth + nx;
            int count = cellCounts[nCellId];
            if (count <= 0) continue;

            int baseIndex = nCellId * maxPerCell;
            // iterate indices up to min(count, maxPerCell)
            int limit = (count < maxPerCell) ? count : maxPerCell;
            for (int k = 0; k < limit; k++)
            {
                int idx = cellIndices[baseIndex + k];
                if (idx == i) continue; // skip self
                EnemyData other = enemies[idx];
                float3 diff = e.position - other.position;
                float d2 = dot(diff, diff);
                if (d2 < rr2 && d2 > 0.000001)
                {
                    float invd = rsqrt(d2); // 1 / sqrt(d2)
                    float3 dir = diff * invd; // normalized
                    // stronger repulsion when closer (1/dist)
                    avoidance += dir * (1.0 / (d2 * invd)); // ~1/dist^2 scaled
                    neighborCount++;
                }
            }
        }
    }

    if (neighborCount > 0)
    {
        // average & scale
        avoidance = avoidance / (float)neighborCount;
        // normalize avoidance safely
        float lenA = length(avoidance);
        if (lenA > minDistanceForNormalize)
            avoidance = (avoidance / lenA) * repulsionStrength;
        else
            avoidance = avoidance * repulsionStrength;
    }

    // --- final velocity & position ---
    float3 finalVel = desiredVel + avoidance;

    // small safeguard: if finalVel contains NaN due to mistakes, fallback
    // (HLSL doesn't have isfinite, so we guard earlier to avoid divisions by zero)
    e.velocity = finalVel;
    e.position += e.velocity * deltaTime;

    // clamp to ground plane (no falling through)
    if (e.position.y < 0.0) e.position.y = 0.0;

    // store back
    enemies[i] = e;
}