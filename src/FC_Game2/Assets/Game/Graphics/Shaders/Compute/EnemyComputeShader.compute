#pragma kernel ClearCells
#pragma kernel BuildGrid
#pragma kernel MoveEnemies

struct EnemyData {
    float3 position;
    float3 velocity;
    float health;
    float padding;
    int active;
    float direction;
    int _pad2;
    int _pad3;
};

RWStructuredBuffer<EnemyData> enemies;

RWStructuredBuffer<int> cellCounts;
RWStructuredBuffer<int> cellIndices;

int gridOriginX;
int gridOriginZ;
int gridWidth;
int gridHeight;
float cellSize;
int maxPerCell;

float3 playerPos;
float deltaTime;
float speed;
float repulsionRadius;
float repulsionStrength;
float minDistanceForNormalize;
float speedFactor;

[numthreads(256,1,1)]
void ClearCells (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= gridWidth * gridHeight) return;
    cellCounts[idx] = 0;
}

[numthreads(256,1,1)]
void BuildGrid (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= enemies.Length) return;

    EnemyData e = enemies[i];
    if (e.health <= 0.0 || e.active == 0) return;

    int gx = (int)floor((e.position.x - (float)gridOriginX) / cellSize);
    int gz = (int)floor((e.position.z - (float)gridOriginZ) / cellSize);

    gx = clamp(gx, 0, gridWidth - 1);
    gz = clamp(gz, 0, gridHeight - 1);
    int cellId = gz * gridWidth + gx;

    int old;
    InterlockedAdd(cellCounts[cellId], 1, old);

    if (old < maxPerCell)
    {
        int baseIndex = cellId * maxPerCell;
        cellIndices[baseIndex + old] = (int)i;
    }
}

[numthreads(256,1,1)]
void MoveEnemies (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= enemies.Length) return;

    EnemyData e = enemies[i];
    if (e.health <= 0.0 || e.active == 0) return;

    float3 toPlayer = playerPos - e.position;
    float distToPlayer = length(toPlayer);
    float3 dirToPlayer = float3(0,0,0);
    if (distToPlayer > minDistanceForNormalize)
        dirToPlayer = toPlayer / distToPlayer;

    float3 desiredVel = dirToPlayer * speed;

    int gx = (int)floor((e.position.x - (float)gridOriginX) / cellSize);
    int gz = (int)floor((e.position.z - (float)gridOriginZ) / cellSize);
    gx = clamp(gx, 0, gridWidth - 1);
    gz = clamp(gz, 0, gridHeight - 1);

    float3 avoidance = float3(0,0,0);
    int neighborCount = 0;
    float rr2 = repulsionRadius * repulsionRadius;

    for (int dz = -1; dz <= 1; dz++)
    {
        int nz = gz + dz;
        if (nz < 0 || nz >= gridHeight) continue;
        for (int dx = -1; dx <= 1; dx++)
        {
            int nx = gx + dx;
            if (nx < 0 || nx >= gridWidth) continue;

            int nCellId = nz * gridWidth + nx;
            int count = cellCounts[nCellId];
            if (count <= 0) continue;

            int baseIndex = nCellId * maxPerCell;
            int limit = (count < maxPerCell) ? count : maxPerCell;
            for (int k = 0; k < limit; k++)
            {
                int idx = cellIndices[baseIndex + k];
                if (idx == i) continue;
                EnemyData other = enemies[idx];
                if (other.active == 0) continue;
                float3 diff = e.position - other.position;
                float d2 = dot(diff, diff);
                if (d2 < rr2 && d2 > 0.000001)
                {
                    float invd = rsqrt(d2);
                    float3 dir = diff * invd;
                    avoidance += dir * (1.0 / (d2 * invd));
                    neighborCount++;
                }
            }
        }
    }

    if (neighborCount > 0)
    {
        avoidance = avoidance / (float)neighborCount;
        float lenA = length(avoidance);
        if (lenA > minDistanceForNormalize)
            avoidance = (avoidance / lenA) * repulsionStrength;
        else
            avoidance = avoidance * repulsionStrength;
    }

    float3 finalVel = desiredVel + avoidance;

    e.velocity = finalVel;
    e.position += e.velocity * deltaTime * speedFactor * e.direction; // direction to move -1 || 1

    if (e.position.y < 0.0) e.position.y = 0.0;

    enemies[i] = e;
}