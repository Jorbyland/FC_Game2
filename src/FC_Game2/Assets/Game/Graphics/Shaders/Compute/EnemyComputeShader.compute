#pragma kernel ClearCells
#pragma kernel BuildGrid
#pragma kernel MoveEnemies

struct EnemyData {
    float3 position;
    float3 velocity;
    float health;
    float padding;
    int active;
    float direction;
    int _pad2;
    int _pad3;
};

RWStructuredBuffer<EnemyData> enemies;

RWStructuredBuffer<int> cellCounts;
RWStructuredBuffer<int> cellIndices;

int gridOriginX;
int gridOriginZ;
int gridWidth;
int gridHeight;
float cellSize;
int maxPerCell;

float3 playerPos;
float deltaTime;
float speed;
float repulsionRadius;
float repulsionStrength;
float minDistanceForNormalize;
float speedFactor;

[numthreads(256,1,1)]
void ClearCells (uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= gridWidth * gridHeight) return;
    cellCounts[idx] = 0;
}

[numthreads(256,1,1)]
void BuildGrid (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= enemies.Length) return;

    EnemyData e = enemies[i];
    if (e.health <= 0.0 || e.active == 0) return;

    int gx = (int)floor((e.position.x - (float)gridOriginX) / cellSize);
    int gz = (int)floor((e.position.z - (float)gridOriginZ) / cellSize);

    gx = clamp(gx, 0, gridWidth - 1);
    gz = clamp(gz, 0, gridHeight - 1);
    int cellId = gz * gridWidth + gx;

    int old;
    InterlockedAdd(cellCounts[cellId], 1, old);

    if (old < maxPerCell)
    {
        int baseIndex = cellId * maxPerCell;
        cellIndices[baseIndex + old] = (int)i;
    }
}

[numthreads(256,1,1)]
void MoveEnemies (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= enemies.Length) return;

    EnemyData e = enemies[i];
    if (e.health <= 0.0 || e.active == 0) return;

    float3 toPlayer = playerPos - e.position;
    float distToPlayer = length(toPlayer);
    float3 dirToPlayer = float3(0,0,0);
    if (distToPlayer > minDistanceForNormalize)
        dirToPlayer = toPlayer / distToPlayer;

    float3 desiredVel = dirToPlayer * speed;

    int gx = (int)floor((e.position.x - (float)gridOriginX) / cellSize);
    int gz = (int)floor((e.position.z - (float)gridOriginZ) / cellSize);
    gx = clamp(gx, 0, gridWidth - 1);
    gz = clamp(gz, 0, gridHeight - 1);

    float3 avoidance = float3(0,0,0);
    float3 verticalAvoidance = float3(0,0,0);
    int neighborCount = 0;
    int verticalNeighborCount = 0;
    float rr2 = repulsionRadius * repulsionRadius;
    float verticalRepulsionRadius = repulsionRadius * 0.8; // Rayon plus petit pour la répulsion verticale
    float vr2 = verticalRepulsionRadius * verticalRepulsionRadius;
    float maxHeightDifference = 0.5; // Hauteur maximale de différence avant répulsion verticale

    for (int dz = -1; dz <= 1; dz++)
    {
        int nz = gz + dz;
        if (nz < 0 || nz >= gridHeight) continue;
        for (int dx = -1; dx <= 1; dx++)
        {
            int nx = gx + dx;
            if (nx < 0 || nx >= gridWidth) continue;

            int nCellId = nz * gridWidth + nx;
            int count = cellCounts[nCellId];
            if (count <= 0) continue;

            int baseIndex = nCellId * maxPerCell;
            int limit = (count < maxPerCell) ? count : maxPerCell;
            for (int k = 0; k < limit; k++)
            {
                int idx = cellIndices[baseIndex + k];
                if (idx == i) continue;
                EnemyData other = enemies[idx];
                if (other.active == 0) continue;
                
                float3 diff = e.position - other.position;
                float d2 = dot(diff, diff);
                
                // Répulsion horizontale (XZ)
                if (d2 < rr2 && d2 > 0.000001)
                {
                    float invd = rsqrt(d2);
                    float3 dir = diff * invd;
                    // Forcer la direction horizontale (Y = 0)
                    dir.y = 0.0;
                    float horizontalDist = length(dir);
                    if (horizontalDist > minDistanceForNormalize)
                    {
                        dir = dir / horizontalDist;
                        avoidance += dir * (1.0 / (d2 * invd));
                        neighborCount++;
                    }
                }
                
                // Répulsion verticale pour éviter les empilements
                float horizontalDist2 = (e.position.x - other.position.x) * (e.position.x - other.position.x) + 
                                       (e.position.z - other.position.z) * (e.position.z - other.position.z);
                float heightDiff = e.position.y - other.position.y;
                
                // Si l'ennemi est au-dessus et proche horizontalement, le pousser vers le bas
                if (horizontalDist2 < vr2 && heightDiff > 0.0 && heightDiff < maxHeightDifference)
                {
                    verticalAvoidance.y -= repulsionStrength * (heightDiff / maxHeightDifference);
                    verticalNeighborCount++;
                }
                // Si l'ennemi est en-dessous et proche horizontalement, se pousser vers le haut
                else if (horizontalDist2 < vr2 && heightDiff < 0.0 && abs(heightDiff) < maxHeightDifference)
                {
                    verticalAvoidance.y += repulsionStrength * (abs(heightDiff) / maxHeightDifference) * 0.5;
                    verticalNeighborCount++;
                }
            }
        }
    }

    if (neighborCount > 0)
    {
        avoidance = avoidance / (float)neighborCount;
        float lenA = length(avoidance);
        if (lenA > minDistanceForNormalize)
            avoidance = (avoidance / lenA) * repulsionStrength;
        else
            avoidance = avoidance * repulsionStrength;
    }
    
    // Appliquer la répulsion verticale
    if (verticalNeighborCount > 0)
    {
        verticalAvoidance = verticalAvoidance / (float)verticalNeighborCount;
    }

    float3 finalVel = desiredVel + avoidance;
    finalVel.y = verticalAvoidance.y; // Appliquer la répulsion verticale séparément

    e.velocity = finalVel;
    e.position += e.velocity * deltaTime * speedFactor * e.direction; // direction to move -1 || 1

    // Maintenir les ennemis au sol et éviter les empilements
    if (e.position.y < 0.0) 
        e.position.y = 0.0;
    else if (e.position.y > 0.1) // Si un ennemi est trop haut, le ramener au sol progressivement
        e.position.y = lerp(e.position.y, 0.0, deltaTime * 5.0);

    enemies[i] = e;
}